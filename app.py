# -*- coding: utf-8 -*-
"""app.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1drnKsznLLWGyCmbxZtP_Y85UQIvkyT5y
"""

import streamlit as st
import pandas as pd
import numpy as np
import shap
import dice_ml
from sklearn.ensemble import RandomForestClassifier
from sklearn.model_selection import train_test_split
from sklearn.compose import ColumnTransformer
from sklearn.preprocessing import OneHotEncoder, StandardScaler
from sklearn.pipeline import Pipeline
from sklearn.impute import SimpleImputer
from sklearn.metrics import accuracy_score, precision_score, recall_score, f1_score, roc_auc_score

# 1. SETUP & DATA LOADING (UPDATED)
@st.cache_resource
def load_data():
    try:
        # Load dataset
        df = pd.read_csv("kidney_dataset.csv")
        df.columns = df.columns.str.lower().str.strip()

        # Identify Target
        target = None
        candidates = ['classification', 'class', 'ckd', 'diagnosis', 'target']
        for t in candidates:
            if t in df.columns:
                target = t
                break
        if target is None: target = df.columns[-1]

        # Clean Target
        if df[target].dtype == 'object':
            df[target] = df[target].astype(str).str.lower().str.strip()
            df[target] = df[target].replace({'ckd\t': 'ckd', ' notckd': 'notckd'})
            mapping = {'ckd': 1, 'notckd': 0, 'yes': 1, 'no': 0}
            df[target] = df[target].map(mapping)
            df = df.dropna(subset=[target])
            df[target] = df[target].astype(int)

        # Drop ID/Leakage
        drop_keywords = ['id', 'unnamed']
        cols_to_drop = [c for c in df.columns if any(k in c for k in drop_keywords)]
        X = df.drop(columns=[target] + cols_to_drop, errors='ignore')
        y = df[target]

        # Identify Feature Types
        num_cols = X.select_dtypes(include=['number']).columns.tolist()
        cat_cols = X.select_dtypes(include=['object']).columns.tolist()

        for col in num_cols:
            if X[col].isnull().any():
                median_val = X[col].median()
                X[col] = X[col].fillna(median_val)
                df[col] = df[col].fillna(median_val)

        for col in cat_cols:
            if X[col].isnull().any():
                mode_val = X[col].mode()[0]
                X[col] = X[col].fillna(mode_val)
                df[col] = df[col].fillna(mode_val)

        # Preprocessing Pipeline
        preprocessor = ColumnTransformer([
            ('num', Pipeline([('imputer', SimpleImputer(strategy='median')), ('scaler', StandardScaler())]), num_cols),
            ('cat', Pipeline([('imputer', SimpleImputer(strategy='most_frequent')), ('onehot', OneHotEncoder(handle_unknown='ignore', sparse_output=False))]), cat_cols)
        ])

        model = Pipeline([
            ('preprocessor', preprocessor),
            ('classifier', RandomForestClassifier(n_estimators=100, random_state=42, max_depth=10))
        ])

        # Split Data
        X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)
        model.fit(X_train, y_train)

        y_pred = model.predict(X_test)
        y_prob = model.predict_proba(X_test)[:, 1]  # Probabilities needed for ROC-AUC

        metrics = {
            "accuracy": accuracy_score(y_test, y_pred),
            "precision": precision_score(y_test, y_pred),
            "recall": recall_score(y_test, y_pred),
            "f1": f1_score(y_test, y_pred),
            "roc_auc": roc_auc_score(y_test, y_prob)
        }

        return model, X_train, X_test, y_test, df, num_cols, cat_cols, target, metrics

    except Exception as e:
        st.error(f"Setup Error: {e}")
        return None, None, None, None, None, [], [], None, {}

# Execute Load
model_pipeline, X_train, X_test, y_test, df_full, num_cols, cat_cols, target_col, metrics = load_data()

#Smart suggestion

ADVICE_DB = {
    'creat': "Limit red meat & creatine supplements. Hydrate.",
    'gfr': "Plant-based diet, weight loss, and BP control.",
    'urea': "Low-protein diet (limit dairy/meat).",
    'bun': "Low-protein diet (limit dairy/meat).",
    'bp': "DASH Diet (Low sodium).",
    'sg': "Drink more water (dehydration indicator).",
    'al': "Strictly limit salt <2300mg. Control blood sugar.",
    'su': "Cut sugar/soda. Switch to whole grains.",
    'hemo': "Iron-rich foods (spinach, beans, lean meat).",
    'pot': "Avoid bananas/potatoes. Choose berries/apples.",
    'sod': "Stop adding table salt. Rinse canned foods."
}

def get_smart_advice(col_name):
    for key, advice in ADVICE_DB.items():
        if key in col_name.lower(): return advice
    return "Consult doctor for diet."

def generate_shap(model, X_train, instance, role, pred_class):
    try:
        prep = model.named_steps['preprocessor']
        clf = model.named_steps['classifier']
        instance_trans = prep.transform(instance)
        explainer = shap.TreeExplainer(clf)
        shap_values = explainer.shap_values(instance_trans)

        vals = shap_values[1] if isinstance(shap_values, list) else shap_values
        vals = np.array(vals).flatten()
        feat_names = (prep.named_transformers_['num'].get_feature_names_out().tolist() +
                      prep.named_transformers_['cat'].get_feature_names_out().tolist())

        min_len = min(len(vals), len(feat_names))
        feat_names = feat_names[:min_len]
        vals = vals[:min_len]

        df_imp = pd.DataFrame({'Feature': feat_names, 'Impact': vals})
        df_imp['Feature'] = df_imp['Feature'].str.replace('num__', '').str.replace('cat__', '')
        df_imp['Abs'] = df_imp['Impact'].abs()
        df_imp = df_imp.sort_values('Abs', ascending=False).head(5)

        if role == "Doctor ü©∫":
            return "### üîç Root Cause Analysis (SHAP)", df_imp[['Feature', 'Impact']]
        else:
            txt = "### ‚ö†Ô∏è Why is my risk high?\nFactors driving risk UP:\n" if pred_class == 1 else "### ‚úÖ Why is my risk low?\nFactors keeping you healthy:\n"
            for _, r in df_imp.iterrows():
                name = r['Feature'].split('_')[0].capitalize()
                txt += f"- **{name}**\n"
            return txt, None
    except Exception as e:
        return f"Error: {e}", None

def generate_dice(model, df, instance, target, role):
    try:
        d = dice_ml.Data(dataframe=df, continuous_features=num_cols, outcome_name=target)
        m = dice_ml.Model(model=model, backend="sklearn")
        exp = dice_ml.Dice(d, m, method="random")
        e = exp.generate_counterfactuals(instance, total_CFs=1, desired_class=0)

        cf_df = e.cf_examples_list[0].final_cfs_df
        original = instance.iloc[0]
        new_vals = cf_df.iloc[0].copy()

        if 'age' in new_vals: new_vals['age'] = original['age']
        is_gfr_improved = (new_vals.get('gfr', 0) > 60) and (original.get('gfr', 0) < 60)

        if is_gfr_improved:
            for col in ['creatinine', 'sc']:
                for c in df.columns:
                    if col in c: new_vals[c] = 1.1
            for col in ['bun', 'urea']:
                for c in df.columns:
                    if col in c: new_vals[c] = 18.0

        changes = []
        for col in num_cols:
            if 'age' in col: continue
            diff = new_vals[col] - original[col]
            if abs(diff) > 0.01:
                advice = get_smart_advice(col)
                changes.append({"Feature": col, "Current": original[col], "Target": new_vals[col], "Advice": advice})

        if role == "Doctor ü©∫":
            if not changes: return "No modifiable risk factors.", None
            return "### üìã Recommended Adjustments", pd.DataFrame(changes)
        else:
            if not changes: return "Maintain healthy lifestyle.", None
            txt = "### ‚úÖ Action Plan\n"
            for c in changes:
                direction = "Lower" if c['Target'] < c['Current'] else "Increase"
                clean = c['Feature'].replace('_', ' ').capitalize()
                txt += f"- **{direction} {clean}**: {c['Advice']}\n"
            return txt, None
    except Exception as e:
        return f"Analysis unavailable: {e}", None

#regulator audit function
def calculate_bias(model, X_test, y_test, df_full):
    test_indices = X_test.index
    df_audit = df_full.loc[test_indices].copy()
    df_audit['Target'] = y_test
    df_audit['Prediction'] = model.predict(X_test)
    df_audit['Correct'] = df_audit['Target'] == df_audit['Prediction']
    df_audit['Age_Group'] = pd.cut(df_audit['age'], bins=[0, 40, 60, 100], labels=['<40', '40-60', '>60'])
    bias_table = df_audit.groupby('Age_Group', observed=False)['Correct'].mean().reset_index()
    bias_table.columns = ['Age Group', 'Accuracy']
    bias_table['Accuracy'] = bias_table['Accuracy'] * 100
    return bias_table

def plot_global_shap(model, X_train):
    prep = model.named_steps['preprocessor']
    clf = model.named_steps['classifier']
    sample = X_train.sample(min(100, len(X_train)))
    sample_trans = prep.transform(sample)
    explainer = shap.TreeExplainer(clf)
    shap_values = explainer.shap_values(sample_trans)
    vals = np.abs(shap_values[1]).mean(0)
    feat_names = (prep.named_transformers_['num'].get_feature_names_out().tolist() +
                  prep.named_transformers_['cat'].get_feature_names_out().tolist())
    min_len = min(len(vals), len(feat_names))
    feat_names = feat_names[:min_len]
    vals = vals[:min_len]
    df = pd.DataFrame({'Feature': feat_names, 'Importance': vals})
    df['Feature'] = df['Feature'].str.replace('num__', '').str.replace('cat__', '')
    return df.sort_values('Importance', ascending=False).head(10)

#UI
st.set_page_config(layout="wide", page_title="Kidney AI System")
col_h1, col_h2 = st.columns([3, 1])
with col_h1: st.title("ü©∫ Kidney Health AI System")
with col_h2: role = st.selectbox("View as:", ["Patient üë§", "Doctor ü©∫", "Regulator ‚öñÔ∏è"])


# VIEW: REGULATOR
if role == "Regulator ‚öñÔ∏è":
    st.header("üõ°Ô∏è AI Governance Dashboard")
    st.markdown("Real-time audit of Model Performance, Fairness, and Logic Safety.")

    # metrics card
    with st.container(border=True):
        st.subheader("1. Model Performance (Test Set)")
        k1, k2, k3, k4, k5 = st.columns(5)

        k1.metric("Accuracy", f"{metrics['accuracy']:.4f}", help="Overall correctness")
        k2.metric("Precision", f"{metrics['precision']:.4f}", help="Positive Predictive Value")
        k3.metric("Recall", f"{metrics['recall']:.4f}", help="Sensitivity (Critical for Medical)")
        k4.metric("F1-score", f"{metrics['f1']:.4f}", help="Harmonic Mean")
        k5.metric("ROC-AUC", f"{metrics['roc_auc']:.4f}", help="Area Under Curve (Discrimination Ability)")

    # SHAP visual
    col_left, col_right = st.columns([1, 1])
    with col_left:
        with st.container(border=True):
            st.subheader("2. Fairness Audit (Age Bias)")
            st.caption("Performance disparity across age groups.")
            bias_df = calculate_bias(model_pipeline, X_test, y_test, df_full)
            st.bar_chart(bias_df.set_index('Age Group'), color="#36A2EB")
            st.dataframe(bias_df.style.format({"Accuracy": "{:.1f}%"}), use_container_width=True, hide_index=True)

    with col_right:
        with st.container(border=True):
            st.subheader("3. Logic Audit (Global SHAP)")
            st.caption("Top features driving decisions.")
            global_shap = plot_global_shap(model_pipeline, X_train)
            st.bar_chart(global_shap.set_index('Feature'), color="#FF6384")
            top_feature = global_shap.iloc[0]['Feature']
            st.success(f"‚úÖ **Logic Check:** Top Driver is **'{top_feature}'**.")

    # safety stress test
    with st.container(border=True):
        st.subheader("4. Safety Protocol Stress Test (DiCE)")
        s1, s2 = st.columns([1, 3])
        run_test = s1.button("üö® Run Live Stress Test", use_container_width=True)

        if run_test:
            with st.spinner("Auditing optimization constraints..."):
                sample = df_full[df_full[target_col] == 1].sample(5)
                results = []
                violations = 0
                avg_changes = 0
                for i in range(len(sample)):
                    pt = sample.iloc[[i]].drop(columns=[target_col], errors='ignore')
                    d = dice_ml.Data(dataframe=df_full, continuous_features=num_cols, outcome_name=target_col)
                    m = dice_ml.Model(model=model_pipeline, backend="sklearn")
                    e = dice_ml.Dice(d, m, method="random").generate_counterfactuals(pt, total_CFs=1, desired_class=0)

                    cf_df = e.cf_examples_list[0].final_cfs_df
                    original = pt.iloc[0]
                    new_vals = cf_df.iloc[0]

                    age_changed = abs(new_vals['age'] - original['age']) > 0.01
                    if age_changed: violations += 1

                    changes = 0
                    for col in num_cols:
                        if abs(new_vals[col] - original[col]) > 0.01: changes += 1
                    avg_changes += changes

                    results.append({"Patient ID": i+1, "Changes": changes, "Age Violation": "‚ö†Ô∏è FAIL" if age_changed else "‚úÖ PASS"})

                avg_changes = avg_changes / 5
                with s2:
                    m1, m2, m3 = st.columns(3)
                    m1.metric("Avg. Changes", f"{avg_changes:.1f}")
                    m2.metric("Violations", f"{violations}/5")
                    m3.metric("Status", "‚úÖ PASSED" if violations == 0 else "‚ùå FAILED")
                    st.dataframe(pd.DataFrame(results), use_container_width=True, hide_index=True)
        else:
            with s2: st.info("Click 'Run Live Stress Test' to audit the counterfactual engine.")

    #Interactive Chat
    st.markdown("---")
    with st.expander("üí¨ Open Interactive Auditor Terminal", expanded=True):
        if "reg_messages" not in st.session_state:
            st.session_state.reg_messages = [{"role": "ai", "content": "System Auditor Online. Query me on **Bias**, **Overfitting**, or **Safety**."}]

        for msg in st.session_state.reg_messages:
            with st.chat_message(msg["role"]):
                st.write(msg["content"])
                if "data" in msg and msg['data'] is not None:
                    if msg['type'] == 'df': st.dataframe(msg['data'], hide_index=True)
                    if msg['type'] == 'chart': st.bar_chart(msg['data'])

        def submit_reg_chat():
            user_input = st.session_state.reg_input
            if user_input:
                st.session_state.reg_messages.append({"role": "user", "content": user_input})
                response = "I didn't understand. Ask about Bias, Overfitting, or Safety."
                data = None
                type_ = None
                q = user_input.lower()

                if "bias" in q or "fair" in q:
                    response = "Bias Report (Age Group Accuracy):"
                    data = calculate_bias(model_pipeline, X_test, y_test, df_full)
                    type_ = 'df'
                elif "overfit" in q:
                    response = f"Gap: {metrics['test_acc'] - metrics['train_acc']:.1%}"
                elif "shap" in q or "logic" in q:
                    response = "Global Feature Importance:"
                    data = plot_global_shap(model_pipeline, X_train).set_index('Feature')
                    type_ = 'chart'

                st.session_state.reg_messages.append({"role": "ai", "content": response, "data": data, "type": type_})
                st.session_state.reg_input = ""

        st.text_input("Audit Query:", key="reg_input", on_change=submit_reg_chat, placeholder="e.g., 'Is there age bias?'")

# VIEW: PATIENT / DOCTOR
else:
    st.sidebar.header("Patient Data")
    if df_full is not None:
        if st.sidebar.button("üé≤ Load Random Patient"):
            row = df_full.sample(1).iloc[0]
            for c in num_cols + cat_cols: st.session_state[f"input_{c}"] = row[c]
            st.session_state['messages'] = []
            if 'result' in st.session_state: del st.session_state['result']

        user_inputs = {}
        for col in num_cols:
            val = st.session_state.get(f"input_{col}", float(df_full[col].mean()))
            user_inputs[col] = st.sidebar.number_input(col, value=float(val), key=f"input_{col}")
        for col in cat_cols:
            options = list(map(str, df_full[col].unique()))
            saved_val = str(st.session_state.get(f"input_{col}", options[0]))
            try: idx = options.index(saved_val)
            except: idx = 0
            user_inputs[col] = st.sidebar.selectbox(col, options, index=idx, key=f"input_{col}")

        input_df = pd.DataFrame([user_inputs])

    col1, col2 = st.columns([1, 2])
    with col1:
        st.subheader("Current Vitals")
        st.dataframe(input_df.T, use_container_width=True)

    with col2:
        if st.button("Run Diagnostics", type="primary", use_container_width=True):
            pred = model_pipeline.predict(input_df)[0]
            prob = model_pipeline.predict_proba(input_df)[0][1]
            st.session_state['result'] = (pred, prob)
            st.session_state['messages'] = [{"role": "ai", "content": "Analysis Complete."}]

        if 'result' in st.session_state:
            pred, prob = st.session_state['result']
            if pred == 1: st.error(f"‚ö†Ô∏è High Risk Detected (Confidence: {prob:.1%})")
            else: st.success(f"‚úÖ Low Risk (Confidence: {(1-prob):.1%})")

            c1, c2 = st.columns(2)
            label_why = "‚ùì Why High?" if pred == 1 else "‚ùì Why Low?"
            label_how = "üíä How to Fix?" if pred == 1 else "üíé How to Maintain?"

            if c1.button(label_why):
                msg, data = generate_shap(model_pipeline, X_train, input_df, role, pred)
                st.session_state.messages.append({"role": "user", "content": "Why?"})
                st.session_state.messages.append({"role": "ai", "content": msg, "data": data, "type": "chart"})

            if c2.button(label_how):
                msg, data = generate_dice(model_pipeline, df_full, input_df, target_col, role)
                st.session_state.messages.append({"role": "user", "content": "How?"})
                st.session_state.messages.append({"role": "ai", "content": msg, "data": data, "type": "df"})

            for msg in st.session_state.messages:
                with st.chat_message(msg['role']):
                    st.write(msg['content'])
                    if "data" in msg and msg['data'] is not None:
                        if msg['type'] == 'chart': st.bar_chart(msg['data'].set_index('Feature'))
                        if msg['type'] == 'df': st.dataframe(msg['data'], hide_index=True)